<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
    <title>Concurrent associative data structure with unsynchronized view</title>
    <meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
    <meta http-equiv="Content-Language" content="en-us">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <style type="text/css">
        .addition {
            color: green;
        }

        .right {
            float: right;
        }

        .changed-deleted {
            background-color: #CFF0FC;
            text-decoration: line-through;
            display: none;
        }

        .addition.changed-deleted {
            color: green;
            background-color: #CFF0FC;
            text-decoration: line-through;
            text-decoration: black double line-through;
            display: none;
        }

        .changed-added {
            background-color: #CFF0FC;
        }

        .notes {
            background-color: #80D080;
        }

        pre {
            line-height: 1.2;
            font-size: 10pt;
            margin-top: 25px;
        }

        .desc {
            margin-left: 35px;
            margin-top: 10px;
            padding: 0;
            white-space: normal;
        }

        body {
            max-width: 1024px;
            margin-left: 25px;
        }

        .cppkeyword {
            color: blue;
        }

        .cppcomment {
            color: green;
        }

        .cppcomment > .cppkeyword {
            color: green;
        }

        .cpptext {
            color: #2E8B57;
        }
        table.gridtable {
            font-family: verdana,arial,sans-serif;
            font-size:11px;
            color:#333333;
            border-width: 1px;
            border-color: #666666;
            border-collapse: collapse;
            width: 100%;
        }
        table.gridtable th {
            border-width: 1px;
            padding: 8px;
            border-style: solid;
            border-color: #666666;
            background-color: #dedede;
            text-align: center;
        }
        table.gridtable td {
            border-width: 1px;
            padding: 8px;
            border-style: solid;
            border-color: #666666;
            background-color: #ffffff;
            text-align: center;
        }
    </style>
</head>
<body bgcolor="#ffffff">
<address>Document number: D0652R1</address>
<address>Project: Programming Language C++</address>
<address>Audience: SG1 Concurrency</address>
<address>&nbsp;</address>
<address>Sergey Murylev, Yandex Ltd, &lt;<a href="mailto:SergeyMurylev@gmail.com">SergeyMurylev@gmail.com</a>&gt;,
    &lt;<a href="mailto:smurylev@yandex-team.ru">smurylev@yandex-team.ru</a>&gt;
</address>
<address>Anton Malakhov, Intel Corp., &lt;<a href="mailto:anton.malakhov@intel.com">anton.malakhov@intel.com</a>&gt;
</address>
<address>Antony Polukhin, Yandex.Taxi Ltd, &lt;<a href="mailto:antoshkka@gmail.com">antoshkka@gmail.com</a>&gt;, &lt;<a
        href="mailto:antoshkka@yandex-team.ru">antoshkka@yandex-team.ru</a>&gt;
</address>
<address>&nbsp;</address>
<address>Date: 2018-06-27</address>
<h1>Concurrent associative data structure with unsynchronized view</h1>

<h2>I. Introduction and Motivation</h2>
<p>There's a lot of use-cases where a concurrent modification of
    unordered associative container is required. There were attempts to add
    such containers/data structures in the past (<a
            href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3425.html">N3425</a>, <a
            href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3732.pdf">N3732</a>, and others...)</p>
<p>This paper is an another attempt to deal with the problem.
    This time we are trying to keep the interface familiar to users, hard to
    misuse but still functional.</p>
<p>Reference implementation is available at <a href="https://github.com/BlazingPhoenix/concurrent-hash-map">https://github.com/BlazingPhoenix/concurrent-hash-map</a>.
</p>

<h2>II. Design decisions</h2>

<h3>A. Allow Open Addressing:</h3>
<p>When users wish to use the concurrent associative data structure, they are searching for performance and scalability.
    Fastest known implementations rely on the <b>open addressing</b> <a
            href="http://www.cs.cmu.edu/%7Edga/papers/memc3-nsdi2013.pdf">MemC3.pdf</a>,
    so interface of this proposal allows to have Open Addressing implementation under the hood.</p>
<p>

</p>
<h3>B. No functions that are easy to misuse:</h3>
<p>In C++17 <code>std::shared_ptr::use_count()</code> function
    was removed because users were misusing it. Users were hoping that the
    result of the function is actual
    at the point where they were trying to use it. However as soon
    as the result is returned from the function it could expire as someone
    modifies the value from other thread.</p>
<p>We followed the C++17 decision and <b>removed all the functions that are useless/dangerous</b> in concurrent
    environments: <code>size()</code>, <code>count()</code>, <code>empty()</code>, <code>buckets_count()</code> and so
    forth.</p>

<h3>C. No iterators:</h3>
<p>Iterators must take care of synchronization, otherwise the
    user can not dereference the iterator at all. If Iterators do some
    synchronization
    it <b>affects performance</b>. Otherwise, if Iterators do some synchronization then <b>deadlocks will happen</b>.
    For example if in first thread we
    iterate from begining to the end of the container and in the
    second thread we iterate from the end to the beginning, then the
    deadlock will
    happen in the middle as the iterators met.</p>

<p>It is possible to drop the open addressing idea and make the
    iterators to have shared ownership of buckets. In that case iterator may
    keep the bucket
    alive. This seems implementable and usable by users, but
    significantly <b>affects performance</b> by adding multiple additional
    atomic operations
    and adding additional indirections. We tried to stick to this
    idea for a long time and minimize the performance impact. Finally we
    created a list of use-cases for concurrent
    associative data structures and found out that in all of those
    use-cases iterators are useless or kill performance of the whole class
    (so are also useless).
    Instead of that, we came up with an idea of <b>unsynchronized view/policy</b>.</p>

<h3>D. View/policy with a full interface:</h3>
<p>This is the <b>killer feature</b> of this proposal that attempts to fix all the limitations from above and provide a
    much more useful interface.</p>

<p>The idea is following: multiple operations on unordered
    containers make sense only if that container is not concurrently
    modified. User may take the
    responsibility that no-one is modifying the container at this
    point and gain all the operations and iterators.</p>

<p>Such approach allows to initialize/prepare the data for container <b>without additional synchronization overhead.</b>
    It also <b>allows advanced usage</b>:
</p>
<ul>
    <li>Multiple threads use the same <code>concurrent_unordered_map</code> for reads and writes simultaneously.</li>
    <li>Multiple threads use <code><span class="cppkeyword">const </span>unordered_map_view
    </code> on the same <code>concurrent_unordered_map</code>
        simultaneously
        (no modifications through <code>concurrent_unordered_map</code> interface are allowed!).
    </li>
    <li>Single thread uses <code> unordered_map_view</code> (no modifications are allowed from other treads!).</li>
    <li>Multiple threads use the same <code><span class="cppkeyword">const </span>concurrent_unordered_map&amp;</code>
        for reads and multiple threads
        use <code><span class="cppkeyword">const </span>unordered_map_view</code> on the same concurrent_unordered_map
        simultaneously
        (ineffective: use multiple <code><span class="cppkeyword">const </span>
            unordered_map_view</code> instead).
    </li>
    <li>
        A user can select whether or not to take lock on whole table contents when it creates view. It can be useful if we
        wanna to suspend concurrent usage by multiple threads to take for example snapshot of contents and serialize state to
        some storage. If the user decided to use view without lock it should be sure that there is no concurrent access form other threads,
        otherwise it leads to undefined behaviour.
    </li>
</ul>

<h3>E. No node operations, different from <code>std::unordered_map</code> iterator invalidation:</h3>
<p>This is a consequence of allowing the open addressing as an underlying implementation.</p>

<h3>F. Allow element visitation using the synchronization of the container:</h3>
<p>This is a very risky decision because it unleashes new ways
    for deadlocking/breaking the container (users may recursively visit the
    same value; users may call heavy functions
    that will degrade the overall performance of the container;
    users can call some parallel functions of the standard library that may
    potentially use the same mutexes as the container implementation...).</p>

<p>However, there's a lot of use-cases where a value must be
    updated depending on value that is in the container. Without a
    visitation, there's no way to do that safely,
    as all the functions return values by copy. See examples <a href="#exampleB">B</a> and <a href="#exampleC">C</a>.
</p>

<h3>G. Allow to iterate over contents of the container:</h3>
<p>
    We've added ability to visit all elements of the container but without appropriate locks.
    In this case contents can be occasionally changed during iteration. Such functionality can be useful for debugging.
</p>

<h3>H. Usage of forwarding references:</h3>
<p>
    Most STL containers was added many years ago. And it was actually earlier than C++11 standard where was added move semantics.
    We considered to use forwarding references instead of method overload to be save copy operations if they
    are movable and get rid of multiple functions with similar signature but different type of arguments.
</p>

<h2>III. Draft interface and informal description</h2>
<p><code>concurrent_unordered_map</code> class is an associative data
    structure that provides an effective key-value storage and does not meet
    the unordered associative container requirements.
    Concurrent member functions calls on the same instance of <code>concurrent_unordered_map</code> have well defined
    behavior.</p>

<pre><span class="cppkeyword">namespace</span> std {
  <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">class </span>Key,
            <span class="cppkeyword">class </span>T,
            <span class="cppkeyword">class </span>Hasher = hash&lt;Key&gt;,
            <span class="cppkeyword">class </span>Equality = equal_to&lt;Key&gt;,
            <span class="cppkeyword">class </span>Allocator = allocator&lt;pair&lt;<span
            class="cppkeyword">const </span>Key, T&gt;&gt; &gt;
  <span class="cppkeyword">class </span>concurrent_unordered_map {
  <span class="cppkeyword">public</span>:
    <span class="cppcomment">// types:
    </span><span class="cppkeyword">class </span>unordered_map_view;
    <span class="cppkeyword">using</span> key_type          = Key;
    <span class="cppkeyword">using</span> mapped_type       = T;
    <span class="cppkeyword">using</span> value_type        = pair&lt;<span class="cppkeyword">const </span>Key, T&gt;;
    <span class="cppkeyword">using</span> hasher            = Hasher;
    <span class="cppkeyword">using</span> key_equal         = Equality;
    <span class="cppkeyword">using</span> allocator_type    = Allocator;
    <span class="cppkeyword">using</span> size_type         = implementation-defined;

    <span class="cppcomment">// construct/destroy:
</span>    <span class="cppkeyword">explicit</span> concurrent_unordered_map(size_type n = implementation-defined,
                                      <span class="cppkeyword">const </span>Hasher&amp; hf = hasher(),
                                      <span class="cppkeyword">const </span>key_equal&amp; eql = key_equal(),
                                      <span class="cppkeyword">const </span>allocator_type&amp; a = allocator_type());
    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> InputIterator&gt;
    concurrent_unordered_map(InputIterator first, InputIterator last,
                             size_type n = implementation-defined,
                             <span class="cppkeyword">const </span>hasher&amp; hf = hasher(),
                             <span class="cppkeyword">const </span>key_equal&amp; eql = key_equal(),
                             <span class="cppkeyword">const </span>allocator_type&amp; a = allocator_type());
    concurrent_unordered_map(<span class="cppkeyword">const </span>Alloc&amp;);
    concurrent_unordered_map(concurrent_unordered_map&amp;&amp;) <span class="cppkeyword">noexcept</span>;
    concurrent_unordered_map(concurrent_unordered_map&amp;&amp;, <span class="cppkeyword">const </span>Allocator&amp;);
    concurrent_unordered_map(initializer_list&lt;value_type&gt; il,
                             size_type n = implementation-defined,
                             <span class="cppkeyword">const </span>hasher&amp; hf = hasher(),
                             <span class="cppkeyword">const </span>key_equal&amp; eql = key_equal(),
                             <span class="cppkeyword">const </span>allocator_type&amp; a = allocator_type());
    ~concurrent_unordered_map();
    <span class="cppcomment">// unordered_map like view with ability to take global table lock
</span>    unordered_map_view make_unordered_map_view(<span class="cppkeyword">bool </span>lock = <span
            class="cppkeyword">false</span>) <span class="cppkeyword">const </span><span
            class="cppkeyword">noexcept</span>;

    <span class="cppcomment">// concurrent-safe assignment:
</span>    concurrent_unordered_map&amp; <span
            class="cppkeyword">operator</span>=(concurrent_unordered_map&amp;&amp;) <span
            class="cppkeyword">noexcept</span>;
    concurrent_unordered_map&amp; <span class="cppkeyword">operator</span>=(initializer_list&lt;value_type&gt;il);

    <span class="cppcomment">// members observers:</span>
    allocator_type get_allocator() <span class="cppkeyword">const</span>;
    hasher hash_function() <span class="cppkeyword">const</span>;
    key_equal key_eq() <span class="cppkeyword">const</span>;

    <span class="cppcomment">// concurrent-safe element retrieval:</span>
    <span class="cppcomment">// the following methods expects that mapped_type is copyable, we just return a copy of the element if it is in the container</span>
    optional&lt;mapped_type&gt; find(<span class="cppkeyword">const </span>key_type&amp; key) const;
    mapped_type find(<span class="cppkeyword">const</span> key_type&amp; key, <span class="cppkeyword">const</span> mapped_type&amp;... default_value) const;

    <span class="cppcomment">// executes `f` under a `lock` if `key` is in *this</span>
    <span class="cppcomment">// the user should avoid of using heavy functions af `f` parameter because it can dramatically slow access of concurrent threads to the bucket with the key.</span>
    <span class="cppcomment">// the method allows get or change value by key where it is not copy constructable</span>
    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> F&gt;
    <span class="cppkeyword">void</span> visit(<span class="cppkeyword">const</span> key_type&amp; key, F&amp; f);
    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> F&gt;
    <span class="cppkeyword">void</span> visit(<span class="cppkeyword">const</span> key_type&amp; key, F&amp f) <span class="cppkeyword">const</span>;

    <span class="cppcomment">// executes `f` under a `lock` for all `key` is in *this, but we don't make global table lock on the operation, in this case you can observe some non repeatable read issues</span>
    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> F&gt;
    <span class="cppkeyword">void</span> visit_all(F&amp; f) <span
                class="cppkeyword">const</span>;

    <span class="cppcomment">// executes `f` under a `lock`. If `key` is not in *this calls emplace(std::forward&lt;Args&gt;(args)...) first.
</span>    <span class="cppkeyword">template</span>&lt;<span
            class="cppkeyword">typename</span> K, <span class="cppkeyword">typename</span> F, <span class="cppkeyword">typename</span>... Args&gt;
    <span class="cppkeyword">void</span> emplace_or_visit(K&amp;&amp; key, F&amp; f, Args&amp;&amp;... args);

    <span class="cppcomment">// concurrent-safe modifiers:</span>
    <span class="cppkeyword">template</span>&lt;<span
            class="cppkeyword">typename</span> K, <span class="cppkeyword">typename</span>... Args&gt;
    <span class="cppkeyword">bool</span> emplace(K&amp;&amp; key, Args&amp;&amp;... val);
    <span class="cppkeyword">template</span>&lt;<span
            class="cppkeyword">typename</span> K, <span class="cppkeyword">typename</span>... Args&gt;
    <span class="cppkeyword">bool</span> insert_or_assign(K&amp;&amp; key, Args&amp;&amp;... val);
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span>... Args&gt;
    size_type update(<span class="cppkeyword">const</span> key_type&amp; key, Args&amp;&amp;... val);

    size_type erase(<span class="cppkeyword">const </span>key_type&amp; key);

    <span class="cppcomment">// whole container state modifiers:</span>
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>H2, <span
            class="cppkeyword">class </span>P2&gt;
    <span class="cppkeyword">void</span> merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>H2, <span
            class="cppkeyword">class </span>P2&gt;
    <span class="cppkeyword">void</span> merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    <span class="cppkeyword">void</span> swap(concurrent_unordered_map&amp;)
        <span class="cppkeyword">noexcept</span>(
            allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
            is_nothrow_swappable_v&lt;Hasher&gt; &amp;&amp;
            is_nothrow_swappable_v&lt;Pred&gt;);
    <span class="cppkeyword">void</span> clear() <span class="cppkeyword">noexcept</span>;
};
</pre>

<p><code>unordered_map_view</code> class refers <code>concurrent_unordered_map</code>
    and provides a concurrent unsafe
    interface to <code>concurrent_unordered_map</code> that satisfies unordered associative container requirements
    (except iterator
    invalidation requirements, <code>load_factor</code> functions, <code>size()</code> complexity requirements and node
    operations).</p>
<p>[ <i>Note:</i> Concurrent non const member functions calls on the instances of <code>unordered_map_view</code> referencing
    the same <code>concurrent_unordered_map</code> are not safe! <i>- end note. </i>] </p>
<p>[ <i>Note:</i> Concurrent member functions calls on the <code>concurrent_unordered_map</code> instance <i>A</i> and
    on the <code>unordered_map_view</code> referencing
    the instance <i>A</i> are not safe! <i>- end note. </i>] </p>


<pre>  <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">class </span>Key, <span class="cppkeyword">class </span>T, <span
        class="cppkeyword">class </span>Hasher, <span class="cppkeyword">class </span>Equality, <span
        class="cppkeyword">class </span>Allocator&gt;
    <span class="cppkeyword">class </span>unordered_map_view {
    concurrent_unordered_map&lt;Key, T, Hasher, Equality, Allocator&gt;&amp; delegate; <span class="cppcomment">// exposition only
</span>
  <span class="cppkeyword">public</span>:
    <span class="cppcomment">// types:
</span>    <span class="cppkeyword">using</span> key_type          = Key;
    <span class="cppkeyword">using</span> mapped_type       = T;
    <span class="cppkeyword">using</span> value_type        = pair&lt;<span class="cppkeyword">const </span>Key, T&gt;;
    <span class="cppkeyword">using</span> hasher            = Hasher;
    <span class="cppkeyword">using</span> key_equal         = Equality;
    <span class="cppkeyword">using</span> allocator_type    = Allocator;

    <span class="cppkeyword">using</span> pointer           = <span class="cppkeyword">typename</span> allocator_traits&lt;Allocator&gt;::pointer;
    <span class="cppkeyword">using</span> const_pointer     = <span class="cppkeyword">typename</span> allocator_traits&lt;Allocator&gt;::const_pointer;
    <span class="cppkeyword">using</span> reference         = value_type&amp;;
    <span class="cppkeyword">using</span> reference         = <span class="cppkeyword">const </span>value_type&amp;;
    <span class="cppkeyword">using</span> size_type         = implementation-defined;
    <span class="cppkeyword">using</span> difference_type   = implementation-defined;
    <span class="cppkeyword">using</span> iterator          = implementation-defined;
    <span class="cppkeyword">using</span> const_iterator    = implementation-defined;
    <span class="cppkeyword">using</span> local_iterator    = implementation-defined;
    <span class="cppkeyword">using</span> const_local_iterator = implementation-defined;

    <span class="cppcomment">// con<span class="cppkeyword">struct</span>/copy/destroy:
</span>    unordered_map_view() = delete;
    unordered_map_view(concurrent_unordered_map&lt;Key, T, Hasher, Equality, Allocator&gt;&amp; delegate);
    unordered_map_view(<span class="cppkeyword">const </span>unordered_map_view&amp;) <span
                class="cppkeyword">noexcept</span> = default;
    unordered_map_view(unordered_map_view&amp;&amp;) <span class="cppkeyword">noexcept</span> = default;
    unordered_map_view&amp; <span class="cppkeyword">operator</span>=(<span class="cppkeyword">const </span>unordered_map_view&amp;) <span
                class="cppkeyword">noexcept</span> = default;
    unordered_map_view&amp; <span class="cppkeyword">operator</span>=(unordered_map_view&amp;&amp;) <span
                class="cppkeyword">noexcept</span> = default;
    ~unordered_map_view() = default;

    <span class="cppcomment">// iterators:
</span>    iterator        begin() <span class="cppkeyword">noexcept</span>;
    const_iterator  begin() <span class="cppkeyword">const </span><span class="cppkeyword">noexcept</span>;
    iterator        end() <span class="cppkeyword">noexcept</span>;
    const_iterator  end() <span class="cppkeyword">const </span><span class="cppkeyword">noexcept</span>;
    const_iterator  cbegin() <span class="cppkeyword">const </span><span class="cppkeyword">noexcept</span>;
    const_iterator  cend() <span class="cppkeyword">const </span><span class="cppkeyword">noexcept</span>;

    <span class="cppcomment">// capacity:
</span>    <span class="cppkeyword">bool</span> empty() <span class="cppkeyword">const </span><span class="cppkeyword">noexcept</span>;
    size_type size() <span class="cppkeyword">const </span><span class="cppkeyword">noexcept</span>;
    size_type max_size() <span class="cppkeyword">const </span><span class="cppkeyword">noexcept</span>;

    <span class="cppcomment">// modifiers:
</span>    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span>... Args&gt;
    pair&lt;iterator, <span class="cppkeyword">bool</span>&gt; emplace(Args&amp;&amp;... args);
    <span style="cppcomment">// We considered have only forwarding reference variant of insert to avoid interface overloading</span>
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>P&gt; pair&lt;iterator, <span class="cppkeyword">bool</span>&gt; insert(P&amp;&amp; x);
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>InputIterator&gt; <span
            class="cppkeyword">void</span> insert(InputIterator first, InputIterator last);
    <span class="cppkeyword">void</span> insert(initializer_list&lt;value_type&gt; il);

    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span>... Args&gt;
      pair&lt;iterator, <span class="cppkeyword">bool</span>&gt; try_emplace(<span class="cppkeyword">const </span>key_type&amp; k, Args&amp;&amp;... args);
    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span>... Args&gt;
      pair&lt;iterator, <span class="cppkeyword">bool</span>&gt; try_emplace(key_type&amp;&amp; k, Args&amp;&amp;... args);
    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">class </span>M&gt;
      pair&lt;iterator, <span class="cppkeyword">bool</span>&gt; insert_or_assign(<span class="cppkeyword">const </span>key_type&amp; k, M&amp;&amp; obj);
    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">class </span>M&gt;
      pair&lt;iterator, <span class="cppkeyword">bool</span>&gt; insert_or_assign(key_type&amp;&amp; k, M&amp;&amp; obj);

    iterator erase(iterator position);
    iterator erase(const_iterator position);
    size_type erase(<span class="cppkeyword">const </span>key_type&amp; k);
    iterator erase(const_iterator first, const_iterator last);
    <span class="cppkeyword">void</span> swap(concurrent_unordered_map&amp;)
        <span class="cppkeyword">noexcept</span>(allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
            is_nothrow_swappable_v&lt;Hasher&gt; &amp;&amp;
            is_nothrow_swappable_v&lt;Pred&gt;);
    <span class="cppkeyword">void</span> clear() <span class="cppkeyword">noexcept</span>;

    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>H2, <span
            class="cppkeyword">class </span>P2&gt;
    <span class="cppkeyword">void</span> merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>H2, <span
            class="cppkeyword">class </span>P2&gt;
    <span class="cppkeyword">void</span> merge(concurrent_unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    <span class="cppcomment">// observers:
</span>    allocator_type get_allocator() const;
    hasher hash_function() const;
    key_equal key_eq() const;

    <span class="cppcomment">// map operations:
</span>    iterator find(<span class="cppkeyword">const </span>key_type&amp; k);
    const_iterator find(<span class="cppkeyword">const </span>key_type&amp; k) const;
    size_type count(<span class="cppkeyword">const </span>key_type&amp; k) const;
    pair&lt;iterator, iterator&gt; equal_range(<span class="cppkeyword">const </span>key_type&amp; k);
    pair&lt;const_iterator, const_iterator&gt; equal_range(<span class="cppkeyword">const </span>key_type&amp; k) const;

    <span class="cppcomment">// element access:
</span>    mapped_type&amp; <span class="cppkeyword">operator</span>[](<span class="cppkeyword">const </span>key_type&amp; k);
    mapped_type&amp; <span class="cppkeyword">operator</span>[](key_type&amp;&amp; k);
    <span class="cppkeyword">const </span>mapped_type&amp; at(<span class="cppkeyword">const </span>key_type&amp; k) const;
    mapped_type&amp; at(<span class="cppkeyword">const </span>key_type&amp; k);

    <span class="cppcomment">// bucket interface:
</span>    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n);
    size_type bucket(<span class="cppkeyword">const </span>key_type&amp; k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    <span class="cppcomment">// hash policy:
    </span><span class="cppkeyword">void</span> rehash(size_type n);
    <span class="cppkeyword">float</span> load_factor() <span class="cppkeyword">const noexcept</span>;
  };
}
</pre>

<p>
    [ <i>Note:</i> Following use-cases are allowed:</p>
<ul>
    <li>Multiple threads use the same <code>concurrent_unordered_map</code> for reads and writes simultaneously</li>
    <li>Multiple threads use <code><span class="cppkeyword">const </span>unordered_map_view</code>
        on the same <code>concurrent_unordered_map</code> simultaneously
        (no modifications through <code>concurrent_unordered_map</code> interface are allowed!)
    </li>
    <li>Single thread uses <code>unordered_map_view</code> (no modifications are allowed from
        other treads!)
    </li>
    <li>Multiple threads use the same <code><span class="cppkeyword">const </span>concurrent_unordered_map&amp;</code>
        for reads and multiple threads use <code><span
                class="cppkeyword">const </span>unordered_map_view</code> on the same <code>concurrent_unordered_map</code>
        simultaneously (ineffective: use multiple <code><span
                class="cppkeyword">const </span>unordered_map_view</code>instead).
    </li>
    <li>
        We decided to get rid of insert like operations with hit to get more
            flexibility with concrete implementation of the container
    </li>
</ul>
<p><i> - end note.</i> ]
</p>


<h2>IV. Detailed description of main methods</h2>
<h3><a name="lookupElements"> A. </a>Lookup elements:</h3>
<pre>    optional&lt;mapped_type&gt; find(<span class="cppkeyword">const </span>key_type&amp; key) <span class="cppkeyword">const</span>;
    mapped_type find(<span class="cppkeyword">const</span> key_type&amp; key, <span class="cppkeyword">const</span> mapped_type&amp; default_value) <span class="cppkeyword">const</span>;
    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> F&gt;
    <span class="cppkeyword">void</span> visit(<span class="cppkeyword">const</span> key_type&amp; key, F&amp; f) <span class="cppkeyword">const</span>;
</pre>
    Method <code>find</code> can be used to obtain a value by a key if container doesn't have the key it returns empty <code>optional</code>,
    the second version of <code>find</code> in this case returns default value constructed from argument list after key argument.
    Method <code>visit</code> instead of <code>find</code> doesn't copy anything and can be used to access non copyable types.
    Functor F should accept <code><span class="cppkeyword">const</span> mapped_type&</code> as argument.

<h3><a name="addElements"> B. </a>Add elements:</h3>
<pre>    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> K, <span class="cppkeyword">typename</span>... Args&gt;
    <span class="cppkeyword">bool</span> emplace(K&amp;&amp; key, Args&amp;&amp;... val);
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span> K, <span class="cppkeyword">typename</span> F, <span class="cppkeyword">typename</span>... Args&gt;
    <span class="cppkeyword">void</span> emplace_or_visit(K&amp;&amp; key, F&amp; f, Args&amp;&amp;... args);
    <span class="cppkeyword">template</span>&lt;<span
            class="cppkeyword">typename</span> K, <span class="cppkeyword">typename</span>... Args&gt;
    <span class="cppkeyword">bool</span> insert_or_assign(K&amp;&amp; key, Args&amp;&amp;... val);
</pre>
    We considered to remove <code>operator []</code> from interface because it is complex and relies on copying.
    Instead of it we've made methods <code>emplace</code> and <code>emplace_or_visit</code>. The first one returns <code>true</code>
    if it created element and <code>false</code> if the key was already in container. Method <code>emplace_or_visit</code>
    also tries to add element but if it can't do it runs functor F with existing value of type <code>mapped_type&</code> as argument.
    Method <code>insert_or_assign</code> also tries to add element and if it unable to do it just overwrites exsiting value.

<h3><a name="modifyElements"> C. </a>Modify elements:</h3>
<pre>    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> F&gt;
    <span class="cppkeyword">void</span> visit(<span class="cppkeyword">const</span> key_type&amp; key, F&amp; f);
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">typename</span>... Args&gt;
    size_type update(<span class="cppkeyword">const</span> key_type&amp; key, Args&amp;&amp;... val);
</pre>
    Method <code>visit</code> works like <code><span class="cppkeyword">const</span></code> method with the same name,
    but functor F takes argument by non <code><span class="cppkeyword">const</span></code> reference and actually can modify it.
    Method <code>update</code> overwrites element by key, return value should be interpreted as number of changed elements.
<h3><a name="eraseElements"> D. </a>Erase elements:</h3>
<pre>    size_type erase(<span class="cppkeyword">const</span> key_type&amp; key);
</pre>
    Method <code>erase</code> has the same meaning as at <code>unordered_map</code>'s method with similar signature.
    It just removes element by key and returns number of removed elements.
<h3><a name="observers"> E. </a>Internal state observers:</h3>
<pre>    allocator_type get_allocator() <span class="cppkeyword">const</span>;
    hasher hash_function() <span class="cppkeyword">const</span>;
    key_equal key_eq() <span class="cppkeyword">const</span>;
</pre>
    The following methods have the same semantics as at <code>unordered_map</code>. They provide ability to access state
    of the container and get a copy of allocator, hash function and key comparator respectively.
<h3><a name="wholeStateModifiers"> F. </a>Whole container state operations:</h3>
<pre>    <span class="cppkeyword">template</span> &lt;<span class="cppkeyword">typename</span> F&gt;
    <span class="cppkeyword">void</span> visit_all(F&amp; f) <span class="cppkeyword">const</span>;
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>H2, <span
            class="cppkeyword">class </span>P2&gt;
    <span class="cppkeyword">void</span> merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    <span class="cppkeyword">template</span>&lt;<span class="cppkeyword">class </span>H2, <span
            class="cppkeyword">class </span>P2&gt;
    <span class="cppkeyword">void</span> merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    <span class="cppkeyword">void</span> swap(concurrent_unordered_map&amp; other);
    <span class="cppkeyword">void</span> clear() <span class="cppkeyword">noexcept</span>;
</pre>
    Method <code>visit_all</code> is designed to iterate over container contents without whole table lock to make
    some kind of debug output, during this operation container can change and it doesn't guarantee full consistency.
    Methods <code>merge</code> fully locks source and moves all elements into <code>*<span class="cppkeyword">this</span></code>.
    Method <code>swap</code> exchanges the contents of the container with those of other. Does not invoke any move, copy, or swap operations on individual elements.
    If all allocator objects considered the same, hash function and key comparator are swappable without exception then we can
    consider <code>swap</code> method <code><span class="cppkeyword">noexcept</span></code>. Method <code>clear</code>
    locks all contents of the container and removes everything from it.
<h3><a name="unordered_map_view"> G. </a>unordered_map like view policy:</h3>
<pre>    unordered_map_view make_unordered_map_view(<span class="cppkeyword">bool </span>lock = <span
        class="cppkeyword">false</span>) <span class="cppkeyword">const </span><span
        class="cppkeyword">noexcept</span>;
</pre>
    Method <code>make_unordered_map_view</code> creates a view of container contents that have very similar interface to
    <code>std::unordered_map</code>. If argument is <code><span class="cppkeyword">true</span></code> it locks all container contents and unlock at destructor of
    view object. If argument is <code><span class="cppkeyword">false</span></code> we doesn't lock anything and we consider that user should beware of concurrent
    access to container. The view doesn't owns the container contents i.e. it should have lower life scope then the container
    otherwise it leads to undefined behaviour.

<h2>V. Some usage examples in pseudo code</h2>
<h3><a name="exampleA">A.</a> User session cache</h3>
<pre><span class="cppkeyword">#include</span> &lt;concurrent_hash_map&gt;
<span class="cppkeyword">#include</span> &lt;string_view&gt;
<span class="cppkeyword">#include</span> &lt;memory&gt;

<span class="cppkeyword">using</span> <span class="cppkeyword">namespace</span> std;
<span class="cppkeyword">void</span> precess_user(string_view name, shared_ptr&lt;<span class="cppkeyword">const </span>user_t&gt; user);
<span class="cppkeyword">auto</span> get_new_user();
<span class="cppkeyword">auto</span> get_request();

int main() {
    concurrent_unordered_map&lt;string_view, shared_ptr&lt;user_t&gt; &gt; users;

    <span class="cppcomment">// single threaded fill
</span>    read_users_from_file(users.lock_table())

    <span class="cppkeyword">constexpr</span> unsigned threads_count = 10;
    <span class="cppkeyword">while</span>(1) {
        <span class="cppcomment">// concurrent work:
</span>        std::atomic&lt;int&gt; b{threads_count * 100500};
        thread threads[threads_count];

        <span class="cppkeyword">for </span>(<span class="cppkeyword">auto</span>&amp; t: threads) {
            <span class="cppcomment">// processing users
</span>            t = thread([&amp;users, &amp;b]() {
                <span class="cppkeyword">while</span> (--b &gt; 0) {
                    <span class="cppkeyword">auto</span> [user_name, data] = <span class="cppkeyword">co_await</span> get_request();
                    <span class="cppkeyword">auto</span> u = users.find(user_name);
                    <span class="cppkeyword">if </span>(!u) <span class="cppkeyword">continue</span>;

                    shared_ptr&lt;<span class="cppkeyword">const </span>user_t&gt; user = *u;
                    precess_user(user, data);
                }
            });
        }

        <span class="cppcomment">// accepting users
</span>        <span class="cppkeyword">while</span> (--b &gt; 0) {
            <span class="cppkeyword">auto</span> [new_user_name, user] = <span class="cppkeyword">co_await</span> get_new_user();
            users.insert(new_user_name, user);
        }

        <span class="cppkeyword">for </span>(<span class="cppkeyword">auto</span>&amp; t: threads) {
            t.join();
        }

        <span class="cppcomment">// single threaded processing:
</span>        <span class="cppkeyword">auto</span> unsafe_users = users.lock_table();
        count_statistics(unsafe_users);
        dump_to_file(unsafe_users);
        cleanup(unsafe_users);
    }
}
</pre>


<h3><a name="exampleB">B.</a> Unique events processor/events deduplicator</h3>
<pre><span class="cppkeyword">#include</span> &lt;concurrent_hash_map&gt;
<span class="cppkeyword">#include</span> &lt;algorithm&gt;

int main() {
    <span class="cppkeyword">using</span> <span class="cppkeyword">namespace</span> std;
    <span class="cppkeyword">using</span> event_id = ...;
    <span class="cppkeyword">struct</span> event_data {
        event_data(<span class="cppkeyword">const </span>event_data&amp;) = delete;
        event_data&amp; <span class="cppkeyword">operator</span>=(<span class="cppkeyword">const </span>event_data&amp;) = delete;
        ...
    };

    concurrent_unordered_map&lt;event_id, unique_ptr&lt;event_data&gt; &gt; events;

    <span class="cppcomment">// Getting unique events.
</span>    <span class="cppkeyword">auto</span> event_generators = get_event_generators();
    for_each(execution::par_unseq, event_generators.begin(), event_generators.end(), [&amp;events](<span
            class="cppkeyword">auto</span>&amp; g) {
        <span class="cppkeyword">while</span> (1) {
            <span class="cppkeyword">auto</span> [event_name, data] = <span class="cppkeyword">co_await</span> g.get_event();
            <span class="cppkeyword">if </span>(event_name.empty()) {
                break; <span class="cppcomment">// no more events
</span>            }

            events.emplace_or_visit(event_name, [&amp;data](unique_ptr&lt;event_data&gt;&amp; v){
                <span class="cppkeyword">if </span>(v || v-&gt;priority() &lt; data-&gt;priority()) {
                    std::swap(data, v);
                }
            }, unique_ptr&lt;event_data&gt;{});
        }
    });

    <span class="cppkeyword">auto</span> v = events.lock_table();
    for_each(execution::par_unseq, v.begin(), v.end(), [](<span class="cppkeyword">auto</span>&amp; e) {
        process(e.first, std::move(e.second));
    });
}
</pre>

<h3><a name="exampleC">C.</a> Gathering statistics</h3>
<pre><span class="cppkeyword">#include</span> &lt;concurrent_hash_map&gt;
<span class="cppkeyword">#include</span> &lt;utility&gt;

int main() {
    <span class="cppkeyword">using</span> <span class="cppkeyword">namespace</span> std;
    <span class="cppkeyword">using</span> id_t = ...;
    <span class="cppkeyword">using</span> use_count_t = size_t;

    concurrent_unordered_map&lt;id_t, use_count_t&gt; stats;

    <span class="cppkeyword">constexpr</span> unsigned threads_count = 10;
    thread threads[threads_count];
    <span class="cppkeyword">for </span>(<span class="cppkeyword">auto</span>&amp; t: threads) {
        t = thread([&amp;stats]() {
            <span class="cppkeyword">while</span> (1) {
                <span class="cppkeyword">auto</span> [id, data] = <span class="cppkeyword">co_await</span> get_something();
                stats.emplace_or_visit(
                    id,
                    [](<span class="cppkeyword">auto</span>&amp; v){ ++v; },
                    0
                );

                precess_stuff(id, data);
            }
        });
    }

    <span class="cppkeyword">for </span>(<span class="cppkeyword">auto</span>&amp; t: threads) {
        t.join();
    }

    process_stats(events.lock_table());
}
</pre>

<h2>VI. Performance benchmark</h2>

<script type="text/javascript" src="amcharts.js"></script>
<script type="text/javascript" src="serial.js"></script>


<script type="text/javascript">
    AmCharts.makeChart("chartdiv",
        {
            "type": "serial",
            "categoryField": "category",
            "sequencedAnimation": false,
            "theme": "default",
            "categoryAxis": {
                "gridPosition": "start",
                "title": "Thread count"
            },
            "trendLines": [],
            "graphs": [
                {
                    "bullet": "round",
                    "id": "AmGraph-1",
                    "title": "boost::synchronized_value<std::unordered_map>",
                    "valueField": "column-1"
                },
                {
                    "bullet": "round",
                    "id": "AmGraph-2",
                    "tabIndex": 6,
                    "title": "std::concurrent_unordered_map prototype",
                    "valueField": "column-2"
                },
                {
                    "id": "AmGraph-5",
                    "bullet": "round",
                    "title": "Sharded unordered map",
                    "valueField": "column-3"
                }
            ],
            "guides": [],
            "valueAxes": [
                {
                    "id": "ValueAxis-1",
                    "title": "Time, milliseconds"
                }
            ],
            "allLabels": [],
            "balloon": {},
            "legend": {
                "enabled": true,
                "useGraphSettings": true
            },
            "titles": [],
            "dataProvider": [
                {
                    "column-1": "837",
                    "column-2": "954",
                    "column-3": "1284",
                    "category": "1"
                },
                {
                    "column-1": "2088",
                    "column-2": "983",
                    "column-3": "2740",
                    "category": "2"
                },
                {
                    "column-1": "5018",
                    "column-2": "972",
                    "column-3": "4408",
                    "category": "4"
                },
                {
                    "column-1": "13867",
                    "column-2": "994",
                    "column-3": "5833",
                    "category": "8"
                },
                {
                    "column-1": "28314",
                    "column-2": "985",
                    "column-3": "11717",
                    "category": "16"
                },
                {
                    "column-1": "61382",
                    "column-2": "1224",
                    "column-3": "19726",
                    "category": "32"
                },
                {
                    "column-1": "136437",
                    "column-2": "4561",
                    "column-3": "38021",
                    "category": "64"
                }
            ]
        }
    );
</script>

We've compared our implementation with a couple of simple other implementations of concurrent unordered map.<br/>
1) The simplest implementation is just a regular unordered_map with guarded by a single mutex, we've implemented mutex guard as boost::synchronized_value.<br/>
2) Many programming languages has internal implementation of concurrent hash map just as fixed number of regular hash maps, each of them has it's own mutex and represents some kind of hash table shard.<br/>
3) Our reference implementation.<br/>
<br/>
The test was very simple:<br/>
* All maps has string keys and int values.<br/>
* We created appropriate number of threads that tries on each iteration to find some random value in the map and add another random value to it. If the key is absent in the map we just fill it with a random value.<br/>
* Each thread had 1000000 of iterations.<br/>
* We use computer with 56 virtual cores & 256GB of memory for the tests.<br/>

<h3 align="center">Concurrent unordered map benchmark</h3>
<table class="gridtable">
    <tr>
        <th>Thread count</th>
        <th>boost::synchronized_value&lt;std::unordered_map&gt;, ms</th>
        <th>Sharded unordered map, ms</th>
        <th>std::concurrent_unordered_map prototype, ms</th>
    </tr>
    <tr>
        <td>1</td>
        <td>837</td>
        <td>1284</td>
        <td>954</td>
    </tr>
    <tr>
        <td>2</td>
        <td>2088</td>
        <td>2740</td>
        <td>983</td>
    </tr>
    <tr>
        <td>4</td>
        <td>5018</td>
        <td>4408</td>
        <td>972</td>
    </tr>
    <tr>
        <td>8</td>
        <td>13867</td>
        <td>5833</td>
        <td>994</td>
    </tr>
    <tr>
        <td>16</td>
        <td>28314</td>
        <td>11717</td>
        <td>985</td>
    </tr>
    <tr>
        <td>32</td>
        <td>61382</td>
        <td>19726</td>
        <td>1224</td>
    </tr>
    <tr>
        <td>64</td>
        <td>136437</td>
        <td>38021</td>
        <td>4561</td>
    </tr>
</table>
<br/>
<div id="chartdiv" style="width: 100%; height: 400px; background-color: #FFFFFF;" ></div>
<br/>
As we can see on the chart performance scales linearly when number of threads is less than number of cores. But when we exceed number of cores we observe significant work time growth. We consider that the algorithm from the reference implementation is rather better then naive implementation and better than implementation from another programming languages.

<script type="text/javascript">
    function colorize_texts(texts) {
        for (var i = 0; i < texts.length; ++i) {
            var text = texts[i].innerHTML;
            text = text.replace(/namespace|enum|void|constexpr|extern|noexcept|bool|template|class |co_await|struct|auto|const |for |while|using|#endif|#else|#ifndef|#ifdef|typename|continue|if |explicit|public|private|operator|#include|inline| char|typedef|static_assert|static_cast|static/g, "<span class='cppkeyword'>$&<\/span>");
            text = text.replace(/\/\/[\s\S]+?\n/g, "<span class='cppcomment'>$&<\/span>");
            //text = text.replace(/\"[\s\S]+?\"/g,"<span class='cpptext'>$&<\/span>");
            texts[i].innerHTML = text;
        }
    }

    colorize_texts(document.getElementsByTagName("pre"));
    colorize_texts(document.getElementsByTagName("code"));

    var show = false;

    function show_hide_deleted() {
        var to_change = document.getElementsByClassName('changed-deleted');
        for (var i = 0; i < to_change.length; ++i) {
            to_change[i].style.display = (show ? 'block' : 'none');
        }

        show = !show;
    }

    show_hide_deleted()
</script>

</body>
</html>
