<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>	
    <title>Concurrent associative data structure with unsynchronized view</title>
    <meta content="http://schemas.microsoft.com/intellisense/ie5" name="vs_targetSchema">
    <meta http-equiv="Content-Language" content="en-us">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <style type="text/css">
        .addition {
            color: green;
        }

        .right {
            float: right;
        }

        .changed-deleted {
            background-color: #CFF0FC;
            text-decoration: line-through;
            display: none;
        }

        .addition.changed-deleted {
            color: green;
            background-color: #CFF0FC;
            text-decoration: line-through;
            text-decoration: black double line-through;
            display: none;
        }

        .changed-added {
            background-color: #CFF0FC;
        }

        .notes {
            background-color: #80D080;
        }

        pre {
            line-height: 1.2;
            font-size: 10pt;
            margin-top: 25px;
        }

        .desc {
            margin-left: 35px;
            margin-top: 10px;
            padding: 0;
            white-space: normal;
        }

        body {
            max-width: 1024px;
            margin-left: 25px;
        }

        .cppkeyword {
            color: blue;
        }

        .cppcomment {
            color: green;
        }

        .cppcomment > .cppkeyword {
            color: green;
        }

        .cpptext {
            color: #2E8B57;
        }
        table.gridtable {
            font-family: verdana,arial,sans-serif;
            font-size:11px;
            color:#333333;
            border-width: 1px;
            border-color: #666666;
            border-collapse: collapse;
            width: 100%;
        }
        table.gridtable th {
            border-width: 1px;
            padding: 8px;
            border-style: solid;
            border-color: #666666;
            background-color: #dedede;
            text-align: center;
        }
        table.gridtable td {
            border-width: 1px;
            padding: 8px;
            border-style: solid;
            border-color: #666666;
            background-color: #ffffff;
            text-align: center;
        }
    </style>
</head>
<body bgcolor="#ffffff">
<address>Document number: D0652R3</address>
<address>Project: Programming Language C++</address>
<address>Audience: SG1 Concurrency</address>
<address>&nbsp;</address>
<address>Sergey Murylev, Yandex Ltd, &lt;<a href="mailto:SergeyMurylev@gmail.com">SergeyMurylev@gmail.com</a>&gt;,
    &lt;<a href="mailto:smurylev@yandex-team.ru">smurylev@yandex-team.ru</a>&gt;
</address>
<address>Anton Malakhov, Intel Corp., &lt;<a href="mailto:anton.malakhov@intel.com">anton.malakhov@intel.com</a>&gt;
</address>
<address>Antony Polukhin, Yandex.Taxi Ltd, &lt;<a href="mailto:antoshkka@gmail.com">antoshkka@gmail.com</a>&gt;, &lt;<a
        href="mailto:antoshkka@yandex-team.ru">antoshkka@yandex-team.ru</a>&gt;
</address>
<address>&nbsp;</address>
<address>Date: 2019-06-11</address>
<h1>Concurrent associative data structure with unsynchronized view</h1>
<p class='changed-added'>Significant changes since <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p0652r2.html">P0652R2</a> are marked with blue.<p>

<h2>I. Introduction and Motivation</h2>
<p>There's a lot of use-cases where a concurrent modification of
        unordered associative container is required. For example, there is a popular web service named <a href="http://memcached.org/">Memcached</a> which simply caches objects in memory.
    Also, we can use it to collect <a href="https://github.com/facebook/hhvm/blob/master/hphp/hhbbc/stats.cpp#L107">statistics</a>,
    to store connection <a href="https://github.com/apache/activemq-cpp/blob/master/activemq-cpp/src/main/activemq/state/ConnectionState.h#L53">metadata</a> or
    just use as lightweight key-value <a href="https://github.com/SoftwareNetwork/sw/blob/master/src/builder/file_storage.h#L72">storage</a>.
    Some big companies like Facebook have it in their standard <a href="https://github.com/facebook/folly/blob/master/folly/concurrency/ConcurrentHashMap.h">library</a>.
    There were attempts to add
    such containers/data structures in the past (<a
            href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3425.html">N3425</a>, <a
            href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3732.pdf">N3732</a>, and others...)</p>
<p>This paper is another attempt to deal with the problem.
    This time we are trying to keep the interface familiar to users, hard to
    misuse but still functional.</p>
<p>Reference implementation is available at <a href="https://github.com/BlazingPhoenix/concurrent-hash-map">https://github.com/BlazingPhoenix/concurrent-hash-map</a>.
</p>

<h2>II. Design decisions</h2>

<h3>A. Allow Open Addressing:</h3>
<p>When users wish to use the concurrent associative data structure, they are searching for performance and scalability.
    Fastest known implementations rely on the <b>open addressing</b> <a
            href="http://www.cs.cmu.edu/%7Edga/papers/memc3-nsdi2013.pdf">MemC3.pdf</a>,
    so the interface of this proposal allows having Open Addressing implementation under the hood.</p>
<p>

</p>
<h3>B. No functions that are easy to misuse:</h3>
<p>In C++17 <code>std::shared_ptr::use_count()</code> function
    was removed because users were misusing it. Users were hoping that the
    result of the function is actual
    at the point where they were trying to use it. However, as soon
    as the result is returned from the function it could expire as someone
    modifies the value from other thread.</p>
<p>We followed the C++17 decision and <b>removed all the functions that are useless/dangerous</b> in concurrent
    environments: <code>size()</code>, <code>count()</code>, <code>empty()</code>, <code>buckets_count()</code> and so
    forth.</p>

<h3>C. No iterators:</h3>
<p>Iterators must take care of synchronization, otherwise, the
    user can not dereference the iterator at all. If Iterators do some
    synchronization
    it <b>affects performance</b>. Otherwise, if Iterators do some synchronization then <b>deadlocks will happen</b>.
    For example, if in first thread we
    iterate from beginning to the end of the container and in the
    second thread we iterate from the end to the beginning, then the
    deadlock will
    happen in the middle as the iterators met.</p>

<p>It is possible to drop the open addressing idea and make the
    iterators to have shared ownership of buckets. In that case, iterator may
    keep the bucket
    alive. This seems implementable and usable by users but
    significantly <b>affects performance</b> by adding multiple additional
    atomic operations
    and adding additional indirections. We tried to stick to this
    idea for a long time and minimize the performance impact. Finally, we
    created a list of use-cases for concurrent
    associative data structures and found out that in all of those
    use-cases iterators are useless or kill performance of the whole class
    (so are also useless).
    Instead of that, we came up with an idea of <b>unsynchronized view/policy</b>.</p>

<h3>D. View/policy with a full interface:</h3>
<p>This is the <b>killer feature</b> of this proposal that attempts to fix all the limitations from above and provide a
    much more useful interface.</p>

<p>The idea is following: multiple operations on unordered
    containers make sense only if that container is not concurrently
    modified. A user may take the
    responsibility that no-one is modifying the container at this
    point and gain all the operations and iterators.</p>

<p>Such approach allows to initialize/prepare the data for container <b>without additional synchronization overhead.</b>
    It also <b>allows advanced usage</b>:
</p>
<ul>
    <li>Multiple threads use the same <code>concurrent_unordered_map</code> for reads and write simultaneously.</li>
    <li>Multiple threads use <code>const unordered_map_view
    </code> on the same <code>concurrent_unordered_map</code>
        simultaneously
        (no modifications through the <code>concurrent_unordered_map</code> interface are allowed!).
    </li>
    <li>The single thread uses <code> unordered_map_view</code> (no modifications are allowed from other threads!).</li>
    <li>Multiple threads use the same <code>const concurrent_unordered_map&amp;</code>
        for reads and multiple threads
        use <code>const unordered_map_view</code> on the same concurrent_unordered_map
        simultaneously
        (ineffective: use multiple <code>const 
            unordered_map_view</code> instead).
    </li>
    <li>
        A user can select whether or not to lock the whole container when it creates a view. It can be useful if we
        want to suspend concurrent usage, to take for example snapshot of contents and serialize state to
        some storage. If the user decided to use view without lock it's the user responsibility to make sure that there is no concurrent access form other threads,
        otherwise, it leads to undefined behavior.
    </li>
</ul>

<h3>E. No node operations, different from <code>std::unordered_map</code> iterator invalidation:</h3>
<p>This is a consequence of allowing the open addressing as an underlying implementation.</p>

<h3>F. Allow element visitation using the synchronization of the container:</h3>
<p>This is a very risky decision because it unleashes new ways
    for deadlocking/breaking the container (users may recursively visit the
    same value; users may call heavy functions
    that will degrade the overall performance of the container;
    users can call some parallel functions of the standard library that may
    potentially use the same mutexes as the container implementation...).</p>

<p>However, there's a lot of use-cases where a value must be
    updated depending on the value that is in the container. Without a
    visitation, there's no way to do that safely,
    as all the functions return values by copy. See examples <a href="#exampleB">B</a> and <a href="#exampleC">C</a>.
</p>

<h3>G. Allow to visit the contents of the container:</h3>
<p>
    We've added an ability to visit all elements of the container without locking the whole container.
    In this case, contents can be occasionally changed during iteration. Such functionality can be useful for debugging.
</p>

<h3>H. We don't propose smart pointer like interface to container items:</h3>
<p>
    Some implementations (for example Intel TBB) provide a possibility to get an item from a container with an appropriate lock guard.
    There are two possible ways to implement it:
    <ol>
        <li>
            We have a lock for each item. In this case, we dramatically increase the size of the container if we use it to store small types,
            and also we add extra CPU effort to lock each item.
            If we store as <code>mapped_type</code> some lock guarded type (for example <code>boost::synchronized_value</code>)
            we can get thread-safe shared ownership of the collection objects without a risk of getting deadlocks.
        </li>
        <li>
            We have a lock for some group of items (bucket). In this case, we can get a deadlock if we try to obtain
            smart pointer like objects for two items from the same bucket and use them simultaneously.
        </li>
    </ol>
    According to thoughts provided above, we considered not to propose such interface because it decreases performance and
    creates a very simple ability for a user to make a deadlock.
</p>

<h2>III. Draft interface and informal description</h2>
<h3>???.1 Header &lt;concurrent_unordered_map&gt;</h3>
<pre>namespace std {
  template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;,
            class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt; &gt;
  class concurrent_unordered_map;

  template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;,
            class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt; &gt;
  void swap(concurrent_unordered_map&lt; Key, T, Hash, Pred, Allocator&gt;&amp; lhs,concurrent_unordered_map&lt; Key, T, Hash, Pred, Allocator&gt;&amp; rhs);
}
</pre>

<h3>???.2 Class <code>concurrent_unordered_map</code></h3>
<pre>namespace std {
  template &lt;class Key,
            class T,
            class Hash = hash&lt;Key&gt;,
            class Pred = equal_to&lt;Key&gt;,
            class Allocator = allocator&lt;pair&lt;const Key, T&gt;&gt; &gt;
  class concurrent_unordered_map {
  public:
    // type aliases
    using key_type          = Key;
    using mapped_type       = T;
    using value_type        = pair&lt;const Key, T&gt;;
    using hasher            = Hash;
    using key_equal         = Pred;
    using allocator_type    = Allocator;
    using size_type         = implementation-defined;

    class unordered_map_view;

    // construct/copy/assign/destroy
    concurrent_unordered_map();
    explicit concurrent_unordered_map(size_type n);
    concurrent_unordered_map(size_type n, const Hash&amp; hf,
                                      const key_equal&amp; eql = key_equal(),
                                      const allocator_type&amp; a = allocator_type());
    template &lt;typename InputIterator&gt;
    concurrent_unordered_map(InputIterator first, InputIterator last,
                             size_type n = implementation-defined,
                             const hasher&amp; hf = hasher(),
                             const key_equal&amp; eql = key_equal(),
                             const allocator_type&amp; a = allocator_type());

    concurrent_unordered_map(const Allocator&amp;);
    concurrent_unordered_map(initializer_list&lt;value_type&gt; il,
                             size_type n = implementation-defined,
                             const hasher&amp; hf = hasher(),
                             const key_equal&amp; eql = key_equal(),
                             const allocator_type&amp; a = allocator_type());

    concurrent_unordered_map(concurrent_unordered_map&amp;&amp; other) noexcept;
    concurrent_unordered_map(concurrent_unordered_map&amp;&amp; other, const Allocator&amp;);

    concurrent_unordered_map&amp; operator=(concurrent_unordered_map&amp;&amp; other) noexcept;
    concurrent_unordered_map&amp; operator=(initializer_list&lt;value_type&gt;il);

    ~concurrent_unordered_map();


    // members observers
    allocator_type get_allocator() const;
    hasher hash_function() const;
    key_equal key_eq() const;


    // visitation
    template &lt;typename Visitor&gt;
    void visit(const key_type&amp; key, Visitor&amp; f);
    template &lt;typename Visitor&gt;
    void visit(const key_type&amp; key, Visitor&amp; f) const;

    template &lt;typename Visitor&gt;
    void visit_all(Visitor&amp; f);
    template &lt;typename Visitor&gt;
    void visit_all(Visitor&amp; f) const;

    template&lt;typename K, typename Visitor, typename... Args&gt;
    bool visit_or_emplace(K&amp;&amp; key, Visitor&amp; f, Args&amp;&amp;... args);


    // access
    optional&lt;mapped_type&gt; find(const key_type&amp; key) const;
    template&lt;typename... Args&gt;
    mapped_type find(const key_type&amp; key, Args&amp;&amp;... args) const;


    // modifiers
    template&lt;typename K, typename... Args&gt;
    bool emplace(K&amp;&amp; key, Args&amp;&amp;... args);
    template&lt;typename K, typename... Args&gt;
    bool insert_or_assign(K&amp;&amp; key, Args&amp;&amp;... args);
    template&lt;typename... Args&gt;
    size_type update(const key_type&amp; key, Args&amp;&amp;... args);
    size_type erase(const key_type&amp; key);

    template&lt;class H2, class P2&gt;
    void merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
    template&lt;class H2, class P2&gt;
    void merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    void swap(concurrent_unordered_map&amp;)
        noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
            is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
            is_nothrow_swappable_v&lt;Pred&gt;);
    void clear() noexcept;


    // view retrieval
    unordered_map_view make_unordered_map_view(bool lock = false) const noexcept;
};
</pre>


<p>The <code>concurrent_unordered_map</code> class is an associative data
    structure that provides an effective key-value storage.
    Concurrent member functions call on the same instance of <code>concurrent_unordered_map</code> do not introduce data races.</p>

<p><code>key_type</code> shall satisfy <i>Cpp17MoveConstructible</i> requirements.</p>
<p><code>mapped_type</code> shall satisfy <i>Cpp17MoveConstructible</i> requirements.</p>

<p>Unless specified otherwise all the member functions of <code>concurrent_unordered_map</code> have the following additional requirements, and remarks:
<div class="desc"><i>Requires:</i> Concurrent member function invocations for the same instance of <code>Hash</code>, <code>Pred</code>, and <code>Allocator</code> do not introduce data races. Concurrent invocations for different instances of <code>Key</code> and <code>T</code> do not introduce data races for the following functions: all the constructors (including default, move and copy constructors); copy and move assignments; destructor.</div>

<div class="desc"><i>Remarks:</i> Call to member function do not introduce data races with other calls to the same or different member functions for the same or different instances of <code>concurrent_unordered_map</code>.</div>

<p>Calls to functions that successfully modify keys or values synchronize with calls to functions successfully reading the value or key of the same keys.</p>
<p>Destructor call for the <code>unordered_map_view</code> referencing the instance of <code>concurrent_unordered_map</code> synchronize with calls to functions successfully reading the value or key of the same instance of <code>concurrent_unordered_map</code>.</p>


<h3>???.2.1 concurrent_unordered_map construct/copy/assign/destroy</h3>
<pre>concurrent_unordered_map();
explicit concurrent_unordered_map(size_type n);
concurrent_unordered_map(size_type n, const Hash&amp; hf,
                                  const key_equal&amp; eql = key_equal(),
                                  const allocator_type&amp; a = allocator_type());
template &lt;typename InputIterator&gt;
concurrent_unordered_map(InputIterator first, InputIterator last,
                         size_type n = implementation-defined,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());

concurrent_unordered_map(const Allocator&amp;);
concurrent_unordered_map(initializer_list&lt;value_type&gt; il,
                         size_type n = implementation-defined,
                         const hasher&amp; hf = hasher(),
                         const key_equal&amp; eql = key_equal(),
                         const allocator_type&amp; a = allocator_type());
</pre>
<div class="desc"><i>Effects:</i> Constructs <code>concurrent_unordered_map</code> with the analogous to the <code>unoredered_map</code> effects.</div>

<pre>concurrent_unordered_map(concurrent_unordered_map&amp;&amp; other) noexcept;
concurrent_unordered_map(concurrent_unordered_map&amp;&amp; other, const Allocator&amp;);
</pre>
<div class="desc"><i>Effects:</i> Constructs <code>concurrent_unordered_map</code> with the content of <code>other</code>, leaving other in valid but unspecified state.</div>
<div class="desc"><i>Remarks:</i> <code>other</code> before the constructor call may not be equal to <code>*this</code> after the constructor call only in case of concurrent access to the <code>other</code>.</div>

<pre>
concurrent_unordered_map&amp; operator=(concurrent_unordered_map&amp;&amp; other) noexcept;
</pre>
<div class="desc"><i>Effects:</i> Assigns the content of <code>other</code> to <code>*this</code>, leaving <code>other</code> in valid but unspecified state.</div>
<div class="desc"><i>Remarks:</i> <code>other</code> before the operator call may not be equal to <code>*this</code> only in case of concurrent access to the <code>other</code> or concurrent access to <code>*this</code>.</div>

<pre>concurrent_unordered_map&amp; operator=(initializer_list&lt;value_type&gt;il);</pre>
<div class="desc"><i>Effects:</i> Assigns the content of <code>li</code> to <code>*this</code>.</div>
<div class="desc"><i>Remarks:</i> <code>li</code> before the operator call may not be equal to <code>*this</code> only in case of concurrent access to <code>*this</code>.</div>


<pre>~concurrent_unordered_map();</pre>
<div class="desc"><i>Remarks:</i> Invocation of this function concurrently with other member functions of the same instance may introduce data races.</div>


<h3>???.2.2 concurrent_unordered_map member observers</h3>
<pre>allocator_type get_allocator() const;
hasher hash_function() const;
key_equal key_eq() const;</pre>
<div class="desc"><i>Expects:</i> Copy construction of <code>allocator_type</code>, <code>hasher</code> and <code>key_equal</code> should not introduce data races.</div>
<div class="desc"><i>Returns:</i> Copies of <code>allocator_type</code>, <code>hasher</code> and <code>key_equal</code> respectively.</div>

<h3>???.2.3 concurrent_unordered_map visitation</h3>
<pre>template &lt;typename Visitor&gt;
void visit(const key_type&amp; key, Visitor&amp; f);</pre>
<div class="desc"><i>Constraints:</i> <code>is_invocable_v&lt;Visitor, mapped_type&amp;&gt;</code> </div>
<div class="desc"><i>Effects:</i> Invokes <code>f</code> on the value stored with a key equivalent to the <code>key</code>.</div>
<div class="desc"><i>Remarks:</i> Modifications of the value in <code>f</code> do not introduce data races.</div>

<pre>template &lt;typename Visitor&gt;
void visit(const key_type&amp; key, Visitor&amp; f) const;</pre>
<div class="desc"><i>Constraints:</i> <code>is_invocable_v&lt;Visitor, const mapped_type&amp;&gt;</code> </div>
<div class="desc"><i>Effects:</i> Invokes <code>f</code> on the value stored with a key equivalent to the <code>key</code>.</div>
<div class="desc"><i>Remarks:</i> Reads of the value passed into <code>f</code> do not introduce data races.</div>

<pre>template &lt;typename Visitor&gt;
void visit_all(Visitor&amp; f);</pre>
<div class="desc"><i>Constraints:</i> <code>is_invocable_v&lt;Visitor, const key_type&amp;, mapped_type&amp;&gt;</code> </div>
<div class="desc"><i>Effects:</i> Sequentially invokes <code>f</code> on key and value pairs stored in <code>*this</code>.</div>
<div class="desc"><i>Remarks:</i> Reads or modifications of non-const arguments passed into <code>f</code> do not introduce data races. It is guaranteed to visit all the keys of <code>*this</code> only if there is no concurrent modifications of <code>*this</code>.<i>[Note:</i> Invocation of <code>f</code> on some
    key and value does not prevent modifications of other keys and values in <code>*this</code>. <i>- end note]</i>.</div>

<pre>template &lt;typename Visitor&gt;
void visit_all(Visitor&amp; f) const;</pre>
<div class="desc"><i>Constraints:</i> <code>is_invocable_v&lt;Visitor, const key_type&amp;, const mapped_type&amp;&gt;</code> </div>
<div class="desc"><i>Effects:</i> Sequentially invokes <code>f</code> on key and value pairs stored in <code>*this</code>.</div>
<div class="desc"><i>Remarks:</i> Reads of the arguments passed into <code>f</code> do not introduce data races.It is guaranteed to visit all the keys of <code>*this</code> only if there is no concurrent modifications of <code>*this</code>.<i>[Note:</i> Invocation of <code>f</code> on some
    key and value does not prevent modifications of other keys and values in <code>*this</code>. <i>- end note]</i>.</div>

<pre>template&lt;typename K, typename Visitor, typename... Args&gt;
bool visit_or_emplace(K&amp;&amp; key, Visitor&amp; f, Args&amp;&amp;... args);</pre>
<div class="desc"><i>Constraints:</i> <code>is_invocable_v&lt;Visitor, mapped_type&amp;&gt; &amp;&amp; is_constructible_v&lt;key_type, K&amp;&amp;&gt; &amp;&amp; is_constructible_v&lt;mapped_type, Args&amp;&amp;...&gt;</code> </div>
<div class="desc"><i>Effects:</i> Invokes <code>f</code> on value stored with the key equivalent to <code>key</code> if such key exist in <code>*this</code>.
Otherwise stores <code>key_type(std::forward&lt;Key&gt;(key))</code> and <code>mapped_type(std::forward&lt;Args&gt;(args)...)</code>.</div>
<div class="desc"><i>Remarks:</i> Construction of <code>key_type</code> and <code>mapped_type</code>, access or modification of the arguments passed into <code>f</code> do not introduce data races.</div>


<h3>???.2.4 concurrent_unordered_map access</h3>
<pre>optional&lt;mapped_type&gt; find(const key_type&amp; key) const;</pre>
<div class="desc"><i>Constraints:</i> <code>is_copy_constructible_v&lt;mapped_type&gt;</code> </div>
<div class="desc"><i>Returns:</i> Empty optional if there is no key equivalent to <code>key</code> in <code>*this</code>, otherwise returns an optional holding a copy of mapped_type for that key.</div>

<pre>template&lt;typename... Args&gt;
mapped_type find(const key_type&amp; key, Args&amp;&amp;... args) const;</pre>
<div class="desc"><i>Constraints:</i> <code>is_copy_constructible_v&lt;mapped_type&gt; &amp;&amp; is_constructible_v&lt;mapped_type, Args&amp;&amp;...&gt;</code> </div>
<div class="desc"><i>Returns:</i> <code>mapped_type(std::forward&lt;Args&gt;(args...))</code> if there is no key equivalent to <code>key</code> in <code>*this</code>, otherwise returns a copy of mapped_type for that key.</div>



<h3>???.2.5 concurrent_unordered_map modifiers</h3>
<pre>template&lt;typename K, typename... Args&gt;
bool emplace(K&amp;&amp; key, Args&amp;&amp;... args);</pre>
<div class="desc"><i>Constraints:</i> <code>is_constructible_v&lt;key_type, K&amp;&amp;&gt; &amp;&amp; is_constructible_v&lt;mapped_type, Args&amp;&amp;...&gt;</code> </div>
<div class="desc"><i>Returns:</i> <code>true</code> if key <code>key</code> was not in the container and function emplaced it, <code>false</code> otherwise</div>

<pre>template&lt;typename K, typename... Args&gt;
bool insert_or_assign(K&amp;&amp; key, Args&amp;&amp;... args);</pre>
<div class="desc"><i>Constraints:</i> <code>is_constructible_v&lt;key_type, K&amp;&amp;&gt; &amp;&amp; is_constructible_v&lt;mapped_type, Args&amp;&amp;...&gt; &amp;&amp; is_move_assigneble_v&lt;mapped_type&gt;</code> </div>
<div class="desc"><i>Returns:</i> <code>true</code> if key <code>key</code> was not in the container and function emplaced it, <code>false</code> if the key was in container and mapped_type for that key was replaced by move assigning <code>mapped_type(std::forward&lt;Args&gt;(args...))</code></div>

<pre>template&lt;typename... Args&gt;
size_type update(const key_type&amp; key, Args&amp;&amp;... args);</pre>
<div class="desc"><i>Constraints:</i> <code>is_constructible_v&lt;mapped_type, Args&amp;&amp;...&gt; &amp;&amp; is_move_assigneble_v&lt;mapped_type&gt;</code> </div>
<div class="desc"><i>Returns:</i> <code>0</code> if the <code>key</code> was not in the container, <code>1</code> if the key was in the container and mapped_type for that key was replaced by move assigning <code>mapped_type(std::forward&lt;Args&gt;(args...))</code></div>

<pre>size_type erase(const key_type&amp; key);</pre>
<div class="desc"><i>Returns:</i> <code>0</code> if the <code>key</code> was not in the container, <code>1</code> if the key was in the container and was erased.</div>

<pre>template&lt;class H2, class P2&gt;
void merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp; source);
template&lt;class H2, class P2&gt;
void merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);</pre>
<div class="desc"><i>Effects:</i> Merges the content of <code>source</code> into <code>*this</code>. For each key and value pair from <code>source</code> apply the following rules:
        If <code>*this</code> already has the key from <code>source</code>, key and value are left in the <code>source</code>. Otherwise, key and value are moved into <code>*this</code>.
        <i>[Note:</i> If new values are being concurrently inserted into <code>source</code> during this operation then at the end of this function invocation <code>source</code> may have keys
        that do not exist in <code>*this</code><i>- end note]</i></div>

<pre>void swap(concurrent_unordered_map&amp; other)
        noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
            is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
            is_nothrow_swappable_v&lt;Pred&gt;);</pre>
<div class="desc"><i>Effects:</i> Swaps the content of <code>other</code> into <code>*this</code>.
        <i>[Note:</i> If new values are being concurrently inserted into <code>other</code> or <code>*this</code> during this operation
        then at the end of this function invocation <code>other</code> may not be equal to <code>*this</code> before the invocation and 
        at the end of this function invocation <code>*this</code> may not be equal to <code>other</code> before the invocation<i>- end note]</i></div>
<div class="desc"><i>Remarks:</i> Does not invoke any move, copy, or swap operations on individual elements.</div>

<pre>void clear() noexcept;</pre>
<div class="desc"><i>Effects:</i> Clears the content of <code>*this</code>.
        <i>[Note:</i> If new values are being concurrently inserted into <code>*this</code> during this operation
        then at the end of this function invocation <code>*this</code> may contain some keys<i>- end note]</i></div>


<h3>???.2.6 concurrent_unordered_map view retrieval</h3>
<pre>unordered_map_view make_unordered_map_view(bool lock = false) const noexcept;</pre>
<div class="desc"><i>Effects:</i> Creates a view of the container contents. If the argument is <code>true</code> any concurrent access to <code>*this</code>through member functions or any subsequent attempt to invoke <code>this-&gt;make_unordered_map_view(true)</code> should block as long as the view is not destroyed.</div>
<div class="desc"><i>Synchronization:</i> Synchronizes with previous modifications of <code>*this</code>.</div>

<h3>???.3 Class <code>unordered_map_view</code></h3>

<pre>  template &lt;class Key, class T, class Hash, class Pred, class Allocator&gt;
    class  concurrent_unordered_map&lt;Key, T, Hash, Pred, Allocator&gt;::unordered_map_view {
    concurrent_unordered_map&lt;Key, T, Hash, Pred, Allocator&gt;&amp; delegate; // exposition only

  public:
    // types:
    using key_type          = Key;
    using mapped_type       = T;
    using value_type        = pair&lt;const Key, T&gt;;
    using hasher            = Hash;
    using key_equal         = Pred;
    using allocator_type    = Allocator;

    using pointer           = typename allocator_traits&lt;Allocator&gt;::pointer;
    using const_pointer     = typename allocator_traits&lt;Allocator&gt;::const_pointer;
    using reference         = value_type&amp;;
    using reference         = const value_type&amp;;
    using size_type         = implementation-defined;
    using difference_type   = implementation-defined;
    using iterator          = implementation-defined;
    using const_iterator    = implementation-defined;
    using local_iterator    = implementation-defined;
    using const_local_iterator = implementation-defined;

    // construct/copy/destroy
    unordered_map_view() = delete;
    unordered_map_view(unordered_map_view&amp;&amp;) noexcept = delete;
    unordered_map_view(const unordered_map_view&amp;) noexcept = delete;
    unordered_map_view&amp; operator=(unordered_map_view&amp;&amp;) noexcept = delete;
    unordered_map_view&amp; operator=(const unordered_map_view&amp;) noexcept = delete;
    ~unordered_map_view();

    // iterators:
    iterator        begin() noexcept;
    const_iterator  begin() const noexcept;
    iterator        end() noexcept;
    const_iterator  end() const noexcept;
    const_iterator  cbegin() const noexcept;
    const_iterator  cend() const noexcept;

    // capacity:
    bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;

    // modifiers:
    template&lt;typename... Args&gt;
    pair&lt;iterator, bool&gt; emplace(Args&amp;&amp;... args);
    // We considered have only forwarding reference variant of insert to avoid interface overloading
    template&lt;class P&gt; pair&lt;iterator, bool&gt; insert(P&amp;&amp; x);
    template&lt;class InputIterator&gt;
    void insert(InputIterator first, InputIterator last);
    void insert(initializer_list&lt;value_type&gt; il);

    template &lt;typename... Args&gt;
      pair&lt;iterator, bool&gt; try_emplace(const key_type&amp; k, Args&amp;&amp;... args);
    template &lt;typename... Args&gt;
      pair&lt;iterator, bool&gt; try_emplace(key_type&amp;&amp; k, Args&amp;&amp;... args);
    template &lt;class M&gt;
      pair&lt;iterator, bool&gt; insert_or_assign(const key_type&amp; k, M&amp;&amp; obj);
    template &lt;class M&gt;
      pair&lt;iterator, bool&gt; insert_or_assign(key_type&amp;&amp; k, M&amp;&amp; obj);

    iterator erase(iterator position);
    iterator erase(const_iterator position);
    size_type erase(const key_type&amp; k);
    iterator erase(const_iterator first, const_iterator last);
    void swap(concurrent_unordered_map&amp;)
        noexcept(allocator_traits&lt;Allocator&gt;::is_always_equal::value &amp;&amp;
            is_nothrow_swappable_v&lt;Hash&gt; &amp;&amp;
            is_nothrow_swappable_v&lt;Pred&gt;);
    void clear() noexcept;

    template&lt;class H2, class P2&gt;
    void merge(concurrent_unordered_map&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);
    template&lt;class H2, class P2&gt;
    void merge(concurrent_unordered_multimap&lt;Key, T, H2, P2, Allocator&gt;&amp;&amp; source);

    // observers:
    allocator_type get_allocator() const;
    hasher hash_function() const;
    key_equal key_eq() const;

    // map operations:
    iterator find(const key_type&amp; k);
    const_iterator find(const key_type&amp; k) const;
    size_type count(const key_type&amp; k) const;
    pair&lt;iterator, iterator&gt; equal_range(const key_type&amp; k);
    pair&lt;const_iterator, const_iterator&gt; equal_range(const key_type&amp; k) const;

    // element access:
    mapped_type&amp; operator[](const key_type&amp; k);
    mapped_type&amp; operator[](key_type&amp;&amp; k);
    const mapped_type&amp; at(const key_type&amp; k) const;
    mapped_type&amp; at(const key_type&amp; k);

    // bucket interface:
    size_type bucket_count() const;
    size_type max_bucket_count() const;
    size_type bucket_size(size_type n);
    size_type bucket(const key_type&amp; k) const;
    local_iterator begin(size_type n);
    const_local_iterator begin(size_type n) const;
    local_iterator end(size_type n);
    const_local_iterator end(size_type n) const;
    const_local_iterator cbegin(size_type n) const;
    const_local_iterator cend(size_type n) const;

    // hash policy:
    void rehash(size_type n);
    float load_factor() const noexcept;
  };
}
</pre>
<p><code>unordered_map_view</code> class refers <code>concurrent_unordered_map</code>
    and provides an interface to <code>concurrent_unordered_map</code> that satisfies unordered associative container requirements [unord.req]
    except iterator invalidation requirements, <code>load_factor</code> functions, <code>size()</code> complexity requirements, buckets and node operations.</p>

<p>[ <i>Note:</i> Concurrent const member functions calls on the instances of <code>unordered_map_view</code> referencing
    the same <code>concurrent_unordered_map</code> introduce data races <i>- end note. </i>] </p>
<p>[ <i>Note:</i> Concurrent member functions calls on the <code>concurrent_unordered_map</code> instance <i>A</i> and
    on the <code>unordered_map_view</code> referencing the instance <i>A</i> introduce data races. <i>- end note. </i>]</p>

<h3>???.3.1 unordered_map_view construct/copy/assign/destroy</h3>
<pre>~unordered_map_view();</pre>
<div class="desc"><i>Effects:</i> If <code>*this</code> was created by <code>make_unordered_map_view(true)</code>
    resumes execution of all the waiting opearions on <code>concurrent_unordered_map</code>.</div>




<h2>IV. Some usage examples in pseudo code</h2>
<h3><a name="exampleA">A.</a> User session cache</h3>
<pre>#include &lt;concurrent_unordered_map&gt;
#include &lt;chrono&gt;
#include &lt;string_view&gt;
#include &lt;memory&gt;

using namespace std;
void precess_user(string_view name, shared_ptr&lt;const user_t&gt; user);
auto get_new_user();
auto get_request();

int main() {
    concurrent_unordered_map&lt;string_view, shared_ptr&lt;user_t&gt; &gt; users;

    // single threaded fill
    read_users_from_file(users.make_unordered_map_view())

    constexpr unsigned threads_count = 10;
    while(1) {
        // concurrent work
        std::atomic&lt;int&gt; b{threads_count * 100500};
        thread threads[threads_count];

        for (auto&amp; t: threads) {
            // processing users
            t = thread([&amp;users, &amp;b]() {
                while (--b &gt; 0) {
                    auto [user_name, data] = co_await get_request();
                    shared_ptr&lt;const user_t&gt; user = users.find(user_name, shared_ptr&lt;const user_t&gt;{});
                    if (!user) continue;

                    precess_user(*user, data);
                }
            });
        }

        // accepting users
        auto start = std::chrono::system_clock::now();
        while (--b &gt; 0) {
            auto [new_user_name, user] = co_await get_new_user();
            users.insert(new_user_name, user);
            if (std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now() - start) > 5000) {
                // debug print rough contents each 5 seconds
                users.visit_all([] (const string_view& name, const shared_ptr&lt;user_t&gt; user) {
                    cout << name << " " << user->status() << endl;
                });
                start = std::chrono::system_clock::now();
            }
        }

        for (auto&amp; t: threads) {
            t.join();
        }

        // single threaded processing
        auto unsafe_users = users.make_unordered_map_view();
        count_statistics(unsafe_users);
        dump_to_file(unsafe_users);
        cleanup(unsafe_users);
    }
}
</pre>


<h3><a name="exampleB">B.</a> Unique events processor/events deduplicator</h3>
<pre>#include &lt;concurrent_unordered_map&gt;
#include &lt;algorithm&gt;

int main() {
    using namespace std;
    using event_id = ...;
    struct event_data {
        event_data(const event_data&amp;) = delete;
        event_data&amp; operator=(const event_data&amp;) = delete;
        ...
    };

    concurrent_unordered_map&lt;event_id, unique_ptr&lt;event_data&gt; &gt; events;

    // Getting unique events.
    auto event_generators = get_event_generators();
    for_each(execution::par_unseq, event_generators.begin(), event_generators.end(), [&amp;events](auto&amp; g) {
        while (1) {
            auto [event_name, data] = co_await g.get_event();
            if (event_name.empty()) {
                break; // no more events
            }

            events.visit_or_emplace(event_name, [&amp;data](unique_ptr&lt;event_data&gt;&amp; v){
                if (v || v-&gt;priority() &lt; data-&gt;priority()) {
                    std::swap(data, v);
                }
            }, unique_ptr&lt;event_data&gt;{});
        }
    });

    auto v = events.make_unordered_map_view();
    for_each(execution::par_unseq, v.begin(), v.end(), [](auto&amp; e) {
        process(e.first, std::move(e.second));
    });
}
</pre>

<h3><a name="exampleC">C.</a> Gathering statistics</h3>
<pre>#include &lt;concurrent_unordered_map&gt;
#include &lt;utility&gt;

int main() {
    using namespace std;
    using id_t = ...;
    using use_count_t = size_t;

    concurrent_unordered_map&lt;id_t, use_count_t&gt; stats;

    constexpr unsigned threads_count = 10;
    thread threads[threads_count];
    for (auto&amp; t: threads) {
        t = thread([&amp;stats]() {
            while (1) {
                auto [id, data] = co_await get_something();
                stats.visit_or_emplace(
                    id,
                    [](auto&amp; v){ ++v; },
                    0
                );

                precess_stuff(id, data);
            }
        });
    }

    for (auto&amp; t: threads) {
        t.join();
    }

    process_stats(events.make_unordered_map_view());
}
</pre>

<h2>V. Performance benchmark</h2>

We've compared our implementation with a couple of simple other implementations of concurrent unordered map.<br>
1) The simplest implementation is just a regular unordered_map with guarded by a single mutex, we've implemented mutex guard as boost::synchronized_value.<br>
2) Our reference implementation.<br>
3) Many programming languages have an internal implementation of a
concurrent hash map just as a fixed number of regular hash maps, each
of them has it's own mutex and represents some kind of hash table
shard.<br>
<span class="changed-added">
4) libcuckoo is the reference implementation of the algorithm presented at
paper <a href="http://www.cs.cmu.edu/%7Edga/papers/memc3-nsdi2013.pdf">MemC3.pdf</a>.<br/>
5) Facebook opensourced a part of the internal library as folly project at
github. It has also an implementation of concurrent hash map.
<br>
</span>
The test was very simple:<br>
* All maps have <span class="changed-added">int</span> keys and int values.<br>
* <span class="changed-added">We created an appropriate number of threads that tries on each
iteration to find some random key in the map and probably insert
another random value by the key to the container
according. Probability of insert operation is called write fraction below.<br></span>
* Each thread had 1000000 of iterations.<br>
* We use a computer with 56 virtual cores & 256GB of memory for the tests.<br>

<h3 align="center">Concurrent unordered map benchmark</h3>
<table class="gridtable">
  <tr>
    <th>Write fraction</th>
    <th>Thread count</th>
    <th>boost::synchronized_value&lt;std::unordered_map&gt;, ms</th>
    <th>std::concurrent_unordered_map prototype, ms</th>
    <th>Sharded unordered map, ms</th>
    <th>libcuckoo cuckoohash_map, ms</th>
    <th>folly::ConcurrentHashMap, ms</th>
  </tr>
  <tr>
    <td>1/1</td>
    <td>1</td>
    <td>432</td>
    <td>265</td>
    <td>420</td>
    <td>369</td>
    <td>658</td>
  </tr>
  <tr>
    <td>1/1</td>
    <td>2</td>
    <td>2602</td>
    <td>382</td>
    <td>1552</td>
    <td>460</td>
    <td>949</td>
  </tr>
  <tr>
    <td>1/1</td>
    <td>4</td>
    <td>5537</td>
    <td>526</td>
    <td>2312</td>
    <td>730</td>
    <td>1612</td>
  </tr>
  <tr>
    <td>1/1</td>
    <td>8</td>
    <td>16539</td>
    <td>856</td>
    <td>3256</td>
    <td>718</td>
    <td>2825</td>
  </tr>
  <tr>
    <td>1/1</td>
    <td>16</td>
    <td>33946</td>
    <td>1334</td>
    <td>7344</td>
    <td>1326</td>
    <td>6805</td>
  </tr>
  <tr>
    <td>1/1</td>
    <td>32</td>
    <td>71692</td>
    <td>2018</td>
    <td>11418</td>
    <td>1556</td>
    <td>13489</td>
  </tr>
  <tr>
    <td>1/1</td>
    <td>64</td>
    <td>151051</td>
    <td>4917</td>
    <td>13536</td>
    <td>7190</td>
    <td>27490</td>
  </tr>
    <tr>
    <td>1/1</td>
    <td>64</td>
    <td>151051</td>
    <td>4917</td>
    <td>13536</td>
    <td>7190</td>
    <td>27490</td>
  </tr>
  <tr>
    <td>1/5</td>
    <td>1</td>
    <td>272</td>
    <td>135</td>
    <td>247</td>
    <td>167</td>
    <td>242</td>
  </tr>
  <tr>
    <td>1/5</td>
    <td>2</td>
    <td>886</td>
    <td>161</td>
    <td>580</td>
    <td>194</td>
    <td>325</td>
  </tr>
  <tr>
    <td>1/5</td>
    <td>4</td>
    <td>2173</td>
    <td>235</td>
    <td>867</td>
    <td>309</td>
    <td>557</td>
  </tr>
  <tr>
    <td>1/5</td>
    <td>8</td>
    <td>8495</td>
    <td>242</td>
    <td>1278</td>
    <td>286</td>
    <td>754</td>
  </tr>
  <tr>
    <td>1/5</td>
    <td>16</td>
    <td>17337</td>
    <td>491</td>
    <td>2495</td>
    <td>464</td>
    <td>1494</td>
  </tr>
  <tr>
    <td>1/5</td>
    <td>32</td>
    <td>38755</td>
    <td>565</td>
    <td>3645</td>
    <td>605</td>
    <td>3085</td>
  </tr>
  <tr>
    <td>1/5</td>
    <td>64</td>
    <td>83737</td>
    <td>1652</td>
    <td>4859</td>
    <td>3356</td>
    <td>6097</td>
  </tr>
  <tr>
    <td>1/20</td>
    <td>1</td>
    <td>214</td>
    <td>135</td>
    <td>214</td>
    <td>185</td>
    <td>205</td>
  </tr>
  <tr>
    <td>1/20</td>
    <td>2</td>
    <td>705</td>
    <td>153</td>
    <td>411</td>
    <td>186</td>
    <td>222</td>
  </tr>
  <tr>
    <td>1/20</td>
    <td>4</td>
    <td>1447</td>
    <td>151</td>
    <td>575</td>
    <td>190</td>
    <td>238</td>
  </tr>
  <tr>
    <td>1/20</td>
    <td>8</td>
    <td>5503</td>
    <td>165</td>
    <td>768</td>
    <td>222</td>
    <td>302</td>
  </tr>
  <tr>
    <td>1/20</td>
    <td>16</td>
    <td>11700</td>
    <td>200</td>
    <td>1359</td>
    <td>325</td>
    <td>492</td>
  </tr>
  <tr>
    <td>1/20</td>
    <td>32</td>
    <td>29675</td>
    <td>285</td>
    <td>1936</td>
    <td>422</td>
    <td>928</td>
  </tr>
  <tr>
    <td>1/20</td>
    <td>64</td>
    <td>65571</td>
    <td>750</td>
    <td>3073</td>
    <td>2889</td>
    <td>1851</td>
  </tr>
</table>
<br>
<br>
<script type="text/javascript" src="amcharts.js"></script>
<script type="text/javascript" src="serial.js"></script>
<script type="text/javascript">
    AmCharts.makeChart("chartdiv1",
        {
            "type": "serial",
            "categoryField": "category",
            "sequencedAnimation": false,
            "theme": "default",
            "categoryAxis": {
                "gridPosition": "start",
         		"title": "Thread count"
            },
            "trendLines": [],
            "graphs": [
                {
                    "bullet": "round",
                    "id": "AmGraph-2",
                    "tabIndex": 6,
                    "title": "std::concurrent_unordered_map prototype",
                    "valueField": "column-2"
                },
                {
                    "id": "AmGraph-3",
                    "bullet": "round",
                    "title": "Sharded unordered map",
                    "valueField": "column-3"
                },
                {
                    "id": "AmGraph-4",
                    "bullet": "round",
                    "title": "libcuckoo cuckoohash_map",
                    "valueField": "column-4"   
                },
                {
                    "id": "AmGraph-5",
                    "bullet": "round",
                    "title": "folly::ConcurrentHashMap",
                    "valueField": "column-5"
                }
            ],
            "guides": [],
     	    "valueAxes": [
                {
                    "id": "ValueAxis-1",
                    "title": "Time, milliseconds"
                }
            ],
            "allLabels": [],
            "balloon": {},
            "legend": {
                "enabled": true,
                "useGraphSettings": true
            },
            "titles": [],
            "dataProvider": [
                {
                    "column-1": "432",
                    "column-2": "265",
                    "column-3": "420",
                    "column-4": "369",
                    "column-5": "658",
                    "category": "1"
                },
                {
                    "column-1": "2602",
                    "column-2": "382",
                    "column-3": "1552",
                    "column-4": "460",
                    "column-5": "949",
                    "category": "2"
                },
                {
                    "column-1": "5537",
                    "column-2": "526",
                    "column-3": "2312",
                    "column-4": "730",
                    "column-5": "1612",
                    "category": "4"
                },
                {
                    "column-1": "16539",
                    "column-2": "856",
                    "column-3": "3256",
                    "column-4": "718",
                    "column-5": "2825",
                    "category": "8"
                },
                {
                    "column-1": "33946",
                    "column-2": "1334",
                    "column-3": "7344",
                    "column-4": "1326",
                    "column-5": "6805",
                    "category": "16"
                },
                {
                    "column-1": "71692",
                    "column-2": "2018",
                    "column-3": "11418",
                    "column-4": "1556",
                    "column-5": "13489",
                    "category": "32"
                },
                {
                    "column-1": "151051",
                    "column-2": "4917",
                    "column-3": "13536",
                    "column-4": "7190",
                    "column-5": "27490",
                    "category": "64"
                }
            ]
        }
    );
</script>
<br/>
<script type="text/javascript">
    AmCharts.makeChart("chartdiv5",
        {
            "type": "serial",
            "categoryField": "category",
            "sequencedAnimation": false,
            "theme": "default",
            "categoryAxis": {
                "gridPosition": "start",
         		"title": "Thread count"
            },
            "trendLines": [],
            "graphs": [
                {
                    "bullet": "round",
                    "id": "AmGraph-2",
                    "tabIndex": 6,
                    "title": "std::concurrent_unordered_map prototype",
                    "valueField": "column-2"
                },
                {
                    "id": "AmGraph-3",
                    "bullet": "round",
                    "title": "Sharded unordered map",
                    "valueField": "column-3"
                },
                {
                    "id": "AmGraph-4",
                    "bullet": "round",
                    "title": "libcuckoo cuckoohash_map",
                    "valueField": "column-4"   
                },
                {
                    "id": "AmGraph-5",
                    "bullet": "round",
                    "title": "folly::ConcurrentHashMap",
                    "valueField": "column-5"
                }
            ],
            "guides": [],
     	    "valueAxes": [
                {
                    "id": "ValueAxis-1",
                    "title": "Time, milliseconds"
                }
            ],
            "allLabels": [],
            "balloon": {},
            "legend": {
                "enabled": true,
                "useGraphSettings": true
            },
            "titles": [],
            "dataProvider": [
                {
                    "column-1": "272",
                    "column-2": "135",
                    "column-3": "247",
                    "column-4": "167",
                    "column-5": "242",
                    "category": "1"
                },
                {
                    "column-1": "886",
                    "column-2": "161",
                    "column-3": "580",
                    "column-4": "194",
                    "column-5": "325",
                    "category": "2"
                },
                {
                    "column-1": "2173",
                    "column-2": "235",
                    "column-3": "867",
                    "column-4": "309",
                    "column-5": "557",
                    "category": "4"
                },
                {
                    "column-1": "8495",
                    "column-2": "242",
                    "column-3": "1278",
                    "column-4": "286",
                    "column-5": "754",
                    "category": "8"
                },
                {
                    "column-1": "17337",
                    "column-2": "491",
                    "column-3": "2495",
                    "column-4": "464",
                    "column-5": "1494",
                    "category": "16"
                },
                {
                    "column-1": "38755",
                    "column-2": "565",
                    "column-3": "3645",
                    "column-4": "605",
                    "column-5": "3085",
                    "category": "32"
                },
                {
                    "column-1": "83737",
                    "column-2": "1652",
                    "column-3": "4859",
                    "column-4": "3356",
                    "column-5": "6097",
                    "category": "64"
                }
            ]
        }
    );
</script>
<script type="text/javascript">
    AmCharts.makeChart("chartdiv20",
        {
            "type": "serial",
            "categoryField": "category",
            "sequencedAnimation": false,
            "theme": "default",
            "categoryAxis": {
                "gridPosition": "start",
         		"title": "Thread count"
            },
            "trendLines": [],
            "graphs": [
                {
                    "bullet": "round",
                    "id": "AmGraph-2",
                    "tabIndex": 6,
                    "title": "std::concurrent_unordered_map prototype",
                    "valueField": "column-2"
                },
                {
                    "id": "AmGraph-3",
                    "bullet": "round",
                    "title": "Sharded unordered map",
                    "valueField": "column-3"
                },
                {
                    "id": "AmGraph-4",
                    "bullet": "round",
                    "title": "libcuckoo cuckoohash_map",
                    "valueField": "column-4"   
                },
                {
                    "id": "AmGraph-5",
                    "bullet": "round",
                    "title": "folly::ConcurrentHashMap",
                    "valueField": "column-5"
                }
            ],
            "guides": [],
     	    "valueAxes": [
                {
                    "id": "ValueAxis-1",
                    "title": "Time, milliseconds"
                }
            ],
            "allLabels": [],
            "balloon": {},
            "legend": {
                "enabled": true,
                "useGraphSettings": true
            },
            "titles": [],
            "dataProvider": [
                {
                    "column-1": "214",
                    "column-2": "135",
                    "column-3": "214",
                    "column-4": "185",
                    "column-5": "205",
                    "category": "1"
                },
                {
                    "column-1": "705",
                    "column-2": "153",
                    "column-3": "411",
                    "column-4": "186",
                    "column-5": "222",
                    "category": "2"
                },
                {
                    "column-1": "1447",
                    "column-2": "151",
                    "column-3": "575",
                    "column-4": "190",
                    "column-5": "238",
                    "category": "4"
                },
                {
                    "column-1": "5503",
                    "column-2": "165",
                    "column-3": "768",
                    "column-4": "222",
                    "column-5": "302",
                    "category": "8"
                },
                {
                    "column-1": "11700",
                    "column-2": "200",
                    "column-3": "1359",
                    "column-4": "325",
                    "column-5": "492",
                    "category": "16"
                },
                {
                    "column-1": "29675",
                    "column-2": "285",
                    "column-3": "1936",
                    "column-4": "422",
                    "column-5": "928",
                    "category": "32"
                },
                {
                    "column-1": "65571",
                    "column-2": "750",
                    "column-3": "3073",
                    "column-4": "2889",
                    "column-5": "1851",
                    "category": "64"
                }
            ]
        }
    );
</script>
<h4 align="center">Write fraction 1/1</h3>
<div id="chartdiv1" style="width: 100%; height: 400px;
                          background-color: #FFFFFF;" ></div>
<br/>
<h4 align="center">Write fraction 1/5</h3>
<div id="chartdiv5" style="width: 100%; height: 400px;
                           background-color: #FFFFFF;" ></div>
<br/>
<h4 align="center">Write fraction 1/20</h3>
<div id="chartdiv20" style="width: 100%; height: 400px;
                            background-color: #FFFFFF;"></div>
<br/>
As we can see performance scales linearly when the number of threads
is less than the number of cores. But when we exceed the number of cores, we observe
significant work time growth.<span class="changed-added">We consider that the algorithm from the reference
implementation is rather better than naive implementation and better than popular
opensource implementations.</span>

<script type="text/javascript">
    function colorize_texts(texts) {
        for (var i = 0; i < texts.length; ++i) {
            var text = texts[i].innerHTML;
            text = text.replace(/namespace|enum|void|constexpr|extern|noexcept|bool|template|class |co_await|break|int |auto|const |for |while|using|#endif|#else|#ifndef|#ifdef|typename|continue|if |explicit|public|private|operator|#include|inline| char|typedef|static_assert|static_cast|static/g, "<span class='cppkeyword'>$&<\/span>");
            text = text.replace(/\/\/[\s\S]+?\n/g, "<span class='cppcomment'>$&<\/span>");
            //text = text.replace(/\"[\s\S]+?\"/g,"<span class='cpptext'>$&<\/span>");
            texts[i].innerHTML = text;
        }
    }

    colorize_texts(document.getElementsByTagName("pre"));
    colorize_texts(document.getElementsByTagName("code"));

    var show = false;

    function show_hide_deleted() {
        var to_change = document.getElementsByClassName('changed-deleted');
        for (var i = 0; i < to_change.length; ++i) {
            to_change[i].style.display = (show ? 'block' : 'none');
        }

        show = !show;
    }

    show_hide_deleted()
</script>

</body>
</html>
